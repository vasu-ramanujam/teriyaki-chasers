#!/usr/bin/env python3
"""
justRun.py — one-file bootstrapper for the backend

Usage:
  python justRun.py [--port 8000] [--reload]

Assumptions:
- This file lives in the backend/ directory next to run.py and init_db.py
- If `requirements.txt` exists, it will be used; otherwise a baseline set is installed.
- If `.env` is missing, it will be created with SQLite defaults so anyone can run locally.
"""

import argparse
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path
from textwrap import dedent

BASELINE_REQUIREMENTS = [
    # Web framework
    "fastapi>=0.115",
    "uvicorn[standard]>=0.30",
    # ORM + DB
    "SQLAlchemy>=2.0",
    "pydantic>=2.8",
    "pydantic-settings>=2.4",
    "python-dotenv>=1.0",
    "psycopg2-binary>=2.9; platform_system != 'Windows'",  # optional for Postgres users
    # Nice to haves
    "requests>=2.32",
]

DEFAULT_ENV = dedent(
    """\
    # ---- Auto-generated by justRun.py ----
    # Local dev uses SQLite by default; swap to Postgres if desired.
    DATABASE_URL=sqlite:///animal_explorer.db

    # Where the API should advertise itself (used by your frontend if needed)
    API_BASE_URL=http://127.0.0.1:8000

    # Maps/provider configuration (fill tokens only if you use them)
    DIRECTIONS_PROVIDER=mapbox
    MAPBOX_ACCESS_TOKEN=

    # Optional external APIs (leave blank if not used)
    OPENAI_API_KEY=
    INATURALIST_API_KEY=
    BIRDWEATHER_API_KEY=
    """
)

def run(cmd, env=None, cwd=None, check=True):
    """Run a subprocess with nice logging."""
    print(f"\n$ {' '.join(cmd)}")
    return subprocess.run(cmd, env=env, cwd=cwd, check=check)

def ensure_venv(backend_dir: Path) -> Path:
    venv_dir = backend_dir / ".venv"
    if not venv_dir.exists():
        print("Creating virtual environment at .venv ...")
        run([sys.executable, "-m", "venv", str(venv_dir)])

    if platform.system() == "Windows":
        py = venv_dir / "Scripts" / "python.exe"
    else:
        py = venv_dir / "bin" / "python"

    if not py.exists():
        print("Detected corrupted venv. Recreating .venv ...")
        shutil.rmtree(venv_dir, ignore_errors=True)
        run([sys.executable, "-m", "venv", str(venv_dir)])
        py = venv_dir / ("Scripts/python.exe" if platform.system() == "Windows" else "bin/python")
        if not py.exists():
            raise RuntimeError("Venv seems corrupted: python executable not found in .venv after recreation")

    print("Upgrading pip...")
    run([str(py), "-m", "pip", "install", "--upgrade", "pip", "wheel", "setuptools"])
    return py

def install_requirements(venv_python: Path, backend_dir: Path):
    req = backend_dir / "requirements.txt"
    if req.exists():
        print("Installing dependencies from requirements.txt ...")
        run([str(venv_python), "-m", "pip", "install", "-r", str(req)])
    else:
        print("requirements.txt not found; installing a baseline set of dependencies ...")
        run([str(venv_python), "-m", "pip", "install", *BASELINE_REQUIREMENTS])

def ensure_env_file(backend_dir: Path):
    env_path = backend_dir / ".env"
    if env_path.exists():
        print(".env found — leaving it as is.")
        return
    print("Creating a default .env (SQLite, local dev) ...")
    env_path.write_text(DEFAULT_ENV)
    print(f"Created {env_path}")

def run_init_db(venv_python: Path, backend_dir: Path):
    init_py = backend_dir / "init_db.py"
    if init_py.exists():
        print("Initializing database via init_db.py ...")
        try:
            run([str(venv_python), str(init_py)], cwd=str(backend_dir))
        except subprocess.CalledProcessError as e:
            print("⚠️  init_db.py failed — continuing anyway so the server can still start.")
            print(f"    (You can re-run it later) Exit code: {e.returncode}")
    else:
        print("No init_db.py found; skipping DB initialization.")

def detect_server_entrypoint(backend_dir: Path) -> Path:
    """
    Prefer running run.py (project-specific entry that already calls uvicorn).
    Fallback to attempting uvicorn if we can detect a likely app module.
    """
    run_py = backend_dir / "run.py"
    if run_py.exists():
        return run_py
    # Fallback detection: look for common app modules
    candidates = [
        ("main.py", "main:app"),
        ("app.py", "app:app"),
        ("server.py", "server:app"),
        ("api.py", "api:app"),
    ]
    for fname, _ in candidates:
        if (backend_dir / fname).exists():
            return backend_dir / fname  # we'll handle via uvicorn if not run.py
    return run_py  # non-existent sentinel meaning "we'll try uvicorn heuristics"

def ensure_api_base_url(env):
    # Make sure API_BASE_URL has a default if not supplied by user’s environment
    env.setdefault("API_BASE_URL", "http://127.0.0.1:8000")
    return env

def launch_server(venv_python: Path, backend_dir: Path, port: int, reload: bool):
    env = os.environ.copy()
    env = ensure_api_base_url(env)

    entry = detect_server_entrypoint(backend_dir)

    # If we have run.py, prefer that
    if entry.name == "run.py" and entry.exists():
        print("Launching backend via run.py ...")
        args = [str(venv_python), str(entry)]
        if reload:
            # If your run.py supports --reload/--port, we'll pass them; otherwise it will be ignored harmlessly.
            args += ["--reload"]
        args += ["--port", str(port)]
        run(args, cwd=str(backend_dir), env=env, check=False)
        return

    # Otherwise, attempt to discover an ASGI app and run uvicorn directly.
    print("run.py not found; attempting to launch via uvicorn ...")

    # Heuristic: try common patterns
    module_candidates = []
    if (backend_dir / "main.py").exists():
        module_candidates.append("main:app")
    if (backend_dir / "app").exists() and (backend_dir / "app" / "__init__.py").exists():
        module_candidates.append("app:app")
    if (backend_dir / "server.py").exists():
        module_candidates.append("server:app")
    if (backend_dir / "api.py").exists():
        module_candidates.append("api:app")

    if not module_candidates:
        print("❌ Could not find an ASGI app (e.g., main:app). Please add run.py or main.py with FastAPI app.")
        sys.exit(2)

    # Try each candidate until one starts (non-blocking errors just print)
    for mod in module_candidates:
        try:
            print(f"Trying: uvicorn {mod} --host 0.0.0.0 --port {port}" + (" --reload" if reload else ""))
            run([str(venv_python), "-m", "uvicorn", mod, "--host", "0.0.0.0", "--port", str(port)]
                + (["--reload"] if reload else []),
                cwd=str(backend_dir),
                env=env,
                check=False)
            return
        except Exception as e:
            print(f"Failed launching {mod}: {e}")

def main():
    parser = argparse.ArgumentParser(description="One-shot backend launcher")
    parser.add_argument("--port", type=int, default=8000, help="Port to run the server on (default 8000)")
    parser.add_argument("--reload", action="store_true", help="Enable auto-reload (dev only)")
    args = parser.parse_args()

    # Resolve backend dir as the directory containing this script
    backend_dir = Path(__file__).resolve().parent
    os.chdir(str(backend_dir))

    print(f"Working directory: {backend_dir}")
    print(f"Python: {sys.executable}")
    print(f"Platform: {platform.platform()}")

    # 1) Ensure venv and pip
    venv_python = ensure_venv(backend_dir)

    # 2) Install deps
    install_requirements(venv_python, backend_dir)

    # 3) Ensure .env
    ensure_env_file(backend_dir)

    # 4) Initialize DB
    run_init_db(venv_python, backend_dir)

    # 5) Launch server
    launch_server(venv_python, backend_dir, port=args.port, reload=args.reload)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nShutting down (KeyboardInterrupt). Bye!")
